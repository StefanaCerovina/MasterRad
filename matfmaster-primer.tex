% Format teze zasnovan je na paketu memoir
% http://tug.ctan.org/macros/latex/contrib/memoir/memman.pdf ili
% http://texdoc.net/texmf-dist/doc/latex/memoir/memman.pdf
% 
% Prilikom zadavanja klase memoir, navedenim opcijama se podešava 
% veličina slova (12pt) i jednostrano štampanje (oneside).
% Ove parametre možete menjati samo ako pravite nezvanične verzije
% mastera za privatnu upotrebu (na primer, u b5 varijanti ima smisla 
% smanjiti 
\documentclass[12pt,oneside]{memoir}

% Paket koji definiše sve specifičnosti mastera Matematičkog fakulteta
\usepackage{matfmaster}
\usepackage{minted}
\usemintedstyle{perldoc}
\usepackage{listings}
\renewcommand\listingscaption{Kод}
%
% Podrazumevano pismo je ćirilica.
%   Ako koristite pdflatex, a ne xetex, sav latinički tekst na srpskom jeziku
%   treba biti okružen sa \lat{...} ili \begin{latinica}...\end{latinica}.
%
% Opicija [latinica]:
%   ako želite da pišete latiniciom, dodajte opciju "latinica" tj.
%   prethodni paket uključite pomoću: \usepackage[latinica]{matfmaster}.
%   Ako koristite pdflatex, a ne xetex, sav ćirilički tekst treba biti
%   okružen sa \cir{...} ili \begin{cirilica}...\end{cirilica}.
%
% Opcija [biblatex]:
%   ako želite da koristite reference na više jezika i umesto paketa
%   bibtex da koristite BibLaTeX/Biber, dodajte opciju "biblatex" tj.
%   prethodni paket uključite pomoću: \usepackage[biblatex]{matfmaster}
%
% Opcija [b5paper]:
%   ako želite da napravite verziju teze u manjem (b5) formatu, navedite
%   opciju "b5paper", tj. prethodni paket uključite pomoću: 
%   \usepackage[b5paper]{matfmaster}. Tada ima smisla razmisliti o promeni
%   veličine slova (izmenom opcije 12pt na 11pt u \documentclass{memoir}).
%
% Naravno, opcije je moguće kombinovati.
% Npr. \usepackage[b5paper,biblatex]{matfmaster}

% Pomoćni paket koji generiše nasumičan tekst u kojem se javljaju sva slova
% azbuke (nema potrebe koristiti ovo u pravim disertacijama)
\usepackage{pangrami}

% Datoteka sa literaturom u BibTex tj. BibLaTeX/Biber formatu
\bib{matfmaster-primer}

% Ime kandidata na srpskom jeziku (u odabranom pismu)
\autor{Стефана Церовина}
% Naslov teze na srpskom jeziku (u odabranom pismu)
\naslov{Виртуелна машина Дартино- имплементација интерпретатора за платформу МИПС}
% Godina u kojoj je teza predana komisiji
\godina{2016}
% Ime i afilijacija mentora (u odabranom pismu)
\mentor{др Милена \textsc{Вујошевић Јаничић}\\ Универзитет у Београду, Математички факултет}
% Ime i afilijacija prvog člana komisije (u odabranom pismu)
\komisijaA{др Саша \textsc{Малков}\\ Универзитет у Београду, Математички факултет}
% Ime i afilijacija drugog člana komisije (u odabranom pismu)
\komisijaB{др Филип \textsc{Марић}\\ Универзитет у Београду, Математички факултет}
% Ime i afilijacija trećeg člana komisije (opciono)
% \komisijaC{}
% Ime i afilijacija četvrtog člana komisije (opciono)
% \komisijaD{}
% Datum odbrane (obrisati ili iskomentarisati narednu liniju ako datum odbrane nije poznat)
%\datumodbrane{}

% Apstrakt na srpskom jeziku (u odabranom pismu)
\apstr{%

}

% Ključne reči na srpskom jeziku (u odabranom pismu)
\kljucnereci{МИПС, систем са уграђеним рачунаром, интерпретатор,}

\begin{document}
% ==============================================================================
% Uvodni deo teze
\frontmatter
% ==============================================================================
% Naslovna strana
\naslovna
% Strana sa podacima o mentoru i članovima komisije
\komisija
% Strana sa posvetom (u odabranom pismu)
\posveta{Брату, мами и тати}
% Strana sa podacima o disertaciji na srpskom jeziku
\apstrakt
% Sadržaj teze
\tableofcontents*

% ==============================================================================
% Glavni deo teze
\mainmatter
% ==============================================================================

% ------------------------------------------------------------------------------
\chapter{Увод}
Појам ,,Интернет ствари'' (енг.~\textit{Internet of things}), скраћено ИоТ (енг.~\textit{IоТ}), се све чешће среће, и он представља модел повезаности објеката који чине систем у оквиру којег објекти међусобно комуницирају. Реч ,,ствар'' у оквиру појма ,,Интернет ствари'' се односи на систем са уграђеним рачунаром (енг.~\textit{embedded system}) који преноси и прима информације путем мреже. Системи са уграђеним рачунаром су системи специјалне намене, који обављају једну или више функција које тој намени одговарају (паметни телефони, дигитални сатови, паметне утичнице, МП3 плејери, штампачи, дигиталне камере и друго). Модерни системи са уграђеним рачунаром су углавном базирани на микроконтролерима, а ређе на микропроцесорима, зато што микроконтролере карактерише ефикасно управљање процесима у реалном времену, масовна производња, ниска цена и мала потрошња електричне енергије. Сматра се да је потенцијал за развој индустрије система са уграђеним рачунаром велики, и да је будућност у изградњи велики ИоТ система.

Развијање апликација за системе са уграђеним рачунаром се обично своди на програмирање у асемблеру или у програмском језику Ц (енг.~\textit{C}). Најчешће се користе компилатори ГЦЦ (енг.~\textit{GCC}) или ЛЛВМ (енг.~\textit{LLVM}), а од алата за дебаговање, обично алат ГДБ (енг.~\textit{GDB}). Развојно окружење се најчешће налази на другом рачунару, јер микроконтролер садржи малу количину РАМ и флеш меморије, па се на  њему обично не може покренути ниједан регуларни оперативни систем, а и микролинукс често захтева више РАМ меморије од оне којом микроконтролер располаже. Због наведених услова, процес развоја апликација је доста захтеван, подложан грешкама па због тога и спор.

Пошто се веб апликације много брже развијају од апликација за системе са уграђеним рачунаром, компанија Гугл (енг.~\textit{Google}) је дошла на идеју да омогући програмирање система са уграђеним рачунаром у вишем програмском језику Дарт, за који постоји подршка за развој веб, серверских и мобилних апликација. Више о програмском језику Дарт биће речено у поглављу \ref{chp:dart}.

Дарт је прилагођен специфичностима микроконтролера кроз нову библиотеку ,,dartino''. Тако је настала виртуелна машина Дартино, са намером да се програмирање система са уграђеним рачунаром олакша и приближи што већем броју програмера. Дартино омогућава писање апликација за мале микроконтролере, на језику који доста личи на Ц, али је објектно-оријентисан и садржи разне погодности које процес имплементације доста олакшавају, те се апликације могу развијати брже и ефикасније. Ова виртуелна машина је детаљније описана у поглављу \ref{chp:dartino}.

У оквиру Дартино виртуелне машине постојала је подршка за миктроконтролере са Интел и Арм архитектуром процесора. Због широке распрострањености МИПС процесора у системима са уграђеним рачунаром, у оквиру овог рада развијен је интерпретатор за платформу МИПС који је и званично интегрисан у Дартино пројекат. Имплементација интерпретатора описана је у поглављу \ref{chp:implementacija}, док се о платформи МИПС више може прочитати у поглављу \ref{chp:mips}.\\

% ------------------------------------------------------------------------------



% ------------------------------------------------------------------------------
\chapter{МИПС}
\label{chp:mips}
% ------------------------------------------------------------------------------

\section{ЦИСК и РИСК}



% ------------------------------------------------------------------------------
\chapter{Програмски језик Дарт}
\label{chp:dart}
% ------------------------------------------------------------------------------

\section{Уопштено}

\section{Карактеристике}

\subsection{Приватност}

\subsection{Конкурентност}

\subsection{Грешке и упозорења}

\subsection{Променљиве}

\subsection{Функције}

\subsection{Оператори}

\subsection{Класе}

\subsection{Интерфејси}

\subsection{Енумерације}

\subsection{Генерици}

\subsection{Уграђени типови}

\subsection{Библиотеке}

\section{Специфичности у односу на јаваскрипт}

\section{Платформе}


% ------------------------------------------------------------------------------
\chapter{Дартино}
\label{chp:dartino}
% ------------------------------------------------------------------------------
У овом поглављу биће описана Дартино виртуелна машина. На почетку је описано чему служи Дартино и које су компоненте виртуелне машине. Након тога је представљен модел програмирања. У трећем одељку су представљене значајне карактеристике и новине ове виртуелне машине: паралелизам, корутине, изолате, влакна итд. Након тога описане су најзначајније библиотеке у оквиру Дартина и чему оне служе. На крају је описана употреба Дартина из командне линије и улога Дарта и Дартина при покретању програма.
\section{Опис виртуелне машине}

Виртуелна машина представља софтверску симулацију физичког рачунара. У зависности од употребе и степена сличности са физичким рачунаром, виртуелне машине се деле на виртуелне машине за симулирање система и виртуелне машине за симулирање процеса.

Дартино виртуелна машина представља виртуелну машину за симулирање процеса. Виртуелне машине за симулирање процеса додају слој изнад оперативног система, који служи за симулирање програмског окружења, које је независно од платформе, и у оквиру ког се може извршавати један процес. Извршавање више процеса може се постићи креирањем више инстанци виртуелне машине. Овај тип виртуелних машина обезбеђује висок ниво апстракције. Програми се пишу у програмском језику вишег нивоа, и могу се извршавати на различитим платформама. Имплементација виртуелне машине се заснива интерпретатору.

Као што је речено у уводу, Дартино виртуелна машина је настала са циљем да се писање апликација за микроконтролере олакша. Како би се направило боље окружење за рад, потребна је отворена и приступачна платформа, која ће већини програмера бити позната. Потребно је омогућити и статичку анализу кода, допуњавање кода, библиотеке са разним функционалностима, и тиме развијање апликација учинити ефикаснијим.

Пре Дартина је било могуће програмирати микропроцесоре у Дарту, али не и микроконтролере. Због мале количине меморије и мале брзине микроконтролера, виртуелне машине које се на њих смештају морају бити што једноставније. Виртуелна машина обично садржи компилатор изворног кода, некакву компоненту за извршавање, сакупљач отпадака, омогућује препознавање класа и објеката (објектни модел), и има подршку за дебаговање. Како би се уклопила у поменута ограничења које намећу миктроконтролери, Дартино виртуелна машина је поједностављена тиме што не садржи компилатор. Она садржи преостале четири компоненте, које су неопходне када је у питању виши програмски језик као што је Дарт. Направљен је систем у коме су компилатор и окружење за извршавање раздвојени, као што је случај код ГЦЦ-а или ЛЛВМ-а, при чему је систем за дебаговање поједностављен и смањен.

Компилатор може да се налази било где, обично на рачунару где се развија апликација, и он комуницира са окружењем за извршавање које се потенцијално налази на другом систему. Интерфејс за комуникацију је једноставан, јер окружење за извршавање мора бити веома једноставно, како би одговарало карактеристикама миктроконтролера.

Окружење за извршавање садржи командни АПИ, преко ког му компилатор може затражити да уради одређене задатке. Испод тога се заправо налази стек машина, тако да се путем овог АПИ-ја може поставити ново стање на стек окружења за извршавање, могу се правити класе, и дефинисати објекти и методе. Стек машина представља виртуелну машину код које је меморијска структура представљена као стек. То значи да се операције извршавају скидањем операнада са стека, применом операције и уписивањем резултата на стек. Компилатор класама може доделити индентификаторе, помоћу којих при примању објекта назад, може утврдити којој класи објекат припада. Компилатор је Дарт програм, који се покреће помоћу Дарт виртуелне машине, док је окружење за извршавање је Дартино виртуелна машина. Више о извршним фајловима \textbf{dart}, \textbf{dartino-vm} и \textbf{dartino} написано је у одељку \ref{sec:pokretanje}.

\begin{figure}[!ht]
  \centering
  \includegraphics[width=0.8\textwidth]{compiler.jpg}
  \caption{Комуникација ЈИТ компилатора и окружења за извршавање}
  \label{fig:komunikacija}
\end{figure}

Сва комуникација се врши преко жичног протокола, тако да је омогућено удаљено извршавање, и обично је базирано на TCP/IP протоколу. На овај начин велики део посла се пребацује на компилатор, а окружење за извршавање се максимално упрошћава.

Помоћу протокола за комуникацију компилатора и окружења за извршавање, може се постављати структура програма, што обухвата:
\begin{enumerate}
\item Додавање нових класа на стек окружења за извршавање
\item Додавање нових метода на стек окружења за извршавање
\end{enumerate}
Може се мењати структура програма, што обухвата:
\begin{enumerate}
\item Мењање табела метода\\
Може се рећи ,,од овог тренутка желим да ова класа поред метода А има и метод Б''. То значи да је омогућена висока интерактивност са системом.
\item Мењање шема\\
Мењање шема се односи на мењање класе, нпр.~додавањем нових поља. Оно што се дешава у тој ситуацији је да се врши пролаз кроз све инстанце класе, и оне се ажурирају и прилагођавају новом формату класе.
\item Дебаговање
У оквиру дебаговања, могуће је:
\begin{enumerate}
\item Покретање дебагера
\item Постављање зауставних тачака
\item Рестартовање дебагера
\end{enumerate}
Систем за дебаговање је једноставан и ограничен, јер не зна ништа о изворном коду.
\end{enumerate}
\section{Модел програмирања}

Доњи слој чини традиционални оперативни систем са уграђеним рачунаром у реалном времену (нпр. Фри РТОС). Изнад тога се налази Дартино окружење за извршавање, које може извршавати више програма, независно, и они не морају знати ништа једни о другима. Ово се разликује од уобичајених система који раде на оперативном систему уграђеног рачунара, и који обично не могу да извршавају више независних компоненти, на независан начин. За сваки програм можемо имати више процеса, више инстанци програма, или делова програма, који се извршавају конкурентно.

\begin{figure}[!ht]
  \centering
  \includegraphics[width=0.7\textwidth]{arhitektura.jpg}
  \caption{Модел програмирања}
  \label{fig:model}
\end{figure}
На слици \ref{fig:model} је приказана ситуација када имамо 3 програма. Програм2 се тренутно не извршава, за Програм1 су покренуте две инстанце, док се Програм3  извршава у 7 нити.

\section{Значајне карактеристике}

У наставку су наведене најзначајније карактеристике Дартино виртуелне машине.
 
\begin{enumerate} 
\item Лаки процеси

За сваки процес нам је потребно мало меморије, неколико стотина бајтова. Сав код и подаци у меморији се деле, па меморију заузимају само подаци који представљају процес. На овај начин ради већина оперативних система, али је то новина за оперативне системе са уграђеним рачунаром.

\item Блокирање процеса

Процес се може блокирати, при чему се не заузимају ресурси, већ се главна нит враћа систему. Разлог за то је што у системима са уграђеним рачунаром обично имамо мали фиксирани број нити, па не желимо да их блокирамо. 

\item Конкурентни процеси

Уколико процесор има више језгара, процеси се могу извршавати конкурентно.

\begin{listing}
\begin{minted}[bgcolor=olive!10]{javascript}
main() {
  for (int i = 0; i < 4000; i++) {
    Process.spawn(hello(i));
  }
}
void hello(n) {
  print("Hello from \${i}");
}
\end{minted}
\caption{Креирање конкурентних процеса методом \texttt{Process.spawn}}
\label{paralelniprocesi}
\end{listing}

Код \ref{paralelniprocesi} приказује покретање 4000 независних процеса за исписивање поздравне поруке, који ће бити распоређени на одређени број језгара и извршавати се конкуретно. Сваки процес има своју хип меморију, а са осталим процесима може комуницирати само слањем порука. Дартино веома добро распоређује велики број процеса на много мањи број језгара. \textit{Process.spawn} креира нови процес и покреће га.

\begin{listing}
\begin{minted}[bgcolor=olive!10]{javascript}
var server = new ServerSocket("127.0.0.1", 0);
while(true) {
  server.spawnAccept((Socket socket){
	//izvrsava se u novom procesu
	socket.send(UTF.encode("Hello"));
	socket.close();
  })
}
\end{minted}
\caption{Манипулисање надолазећим конекцијама методом \texttt{spawnAccept}}
\label{konekcije}
\end{listing}

У коду \ref{konekcije} се креира ServerSocket који представља сервер, затим се помоћу метода \textit{spawnAccept} креира нови процес. У оквиру тог процеса се чека да клијент успостави конекцију са сервером, и самим тим блокира даље извршавање док се конекција не успостави. При успостављању конекције, клијент (\textit{socket}) шаље серверу (\textit{server}) поздравну поруку. Издвајање комуникације у нови процес је потребно вршити увек када се врши неко комплексније израчунавање пре слања поруке.

\item Комуникација

Комуникација између процеса се обавља слањем порука, помоћу канала и портова. Канал представља један ред порука. Порт представља могућност слања поруке каналу, и без приступа одеђеном порту, не може се слати порука каналу који чека на другој страни порта.

\begin{listing}
\begin{minted}[bgcolor=olive!10]{javascript}
final channel = new Channel();
final port = new Port(channel);
Process.spawn(() {
	int i=0;
	while(i < 50) {
		port.send(i++);
	}
});
while(true) {
	print(channel.receive());
}
\end{minted}
\caption{Комуникација процеса слањем порука на одређени канал}
\label{blokiranje}
\end{listing}
Код \ref{blokiranje} приказује један процес који шаље поруке, и функцију \textit{print} која блокира извршавање све док не прими следећу поруку и испише је.

\item Дељено непроменљиво стање између процеса
Процеси деле само објекте који се не мењају, и то на следећи начин:
\begin{enumerate}
\item Сваки непроменљиви објекат се може слати као порука, без копирања
\item Више процеса могу користити(читати) исти објекат истовремено
\item Нема потребе за експлицитним примитивама за синхронизацију, јер мењање објеката није омогућено
\end{enumerate}

\item Изолате

Изолате (енг.~\textit{Isolates}) су независни воркери (енг.~\textit{Worker} \footnote{Појам који означава нешто између процеса и нити. Извршава се у позадини и тиме не утиче на одзивност система. }), свака изолата има своју хип меморију, и за разлику од нити нема дељења меморије између изолата. Изолате комуницирају само преко порука. Могу се паузирати, наставити и убити.

\begin{listing}
\begin{minted}[bgcolor=olive!10]{javascript}
main() {
  Expect.equals(1597, fib(16));
  Expect.equals(4181, fib(18)); 
}

fib(n) {
  if (n <= 1) return 1;
  var n1 = Isolate.spawn(() => fib(n - 1));
  var n2 = Isolate.spawn(() => fib(n - 2));
  return n1.join() + n2.join();
}
\end{minted}
\caption{Употреба изолата}
\label{isolates}
\end{listing}

Код \ref{isolates} приказује пример употребе изолата за рачунање елемената Фибоначијевог низа, рекурзивно. Покрећу се две независне изолате и на крају се спаја резултат.

\item Влакна

Влакна (енг.~\textit{Fibers}) представљају нити извршавања у оквиру једног процеса, које деле спољну меморију, али не деле непроменљиву меморију. Извршавају се конкурентно, тако да нема паралелизма. Омогућују да више независних нити једног процеса могу чекати на исту ствар(блокирати) независно једна од друге. На овај начин се имплементира вишеструка одвојена контрола тока.

\begin{listing}
\begin{minted}[bgcolor=olive!10]{javascript}
void publishOnChange(Socket socket, String property, Channel input){
  	 int last = 0;
  	 while(true){
   	  int current = input.receive();
    	 if(current != last)
      	 socket.send(UTF.encode('("\$property": \$current)'));
    	 last = current;
  	 }
}

Fiber.fork(() => publishOnChange(server, "temperature", tempSensor));
Fiber.fork(() => publishOnChange(server,"humidity", humSensor));
\end{minted}
\caption{Пример употребе два влакна која чекају на функцију \texttt{publishOnChange}, при чему не зависе једно од другог}
\label{fibers}
\end{listing}

Код \ref{fibers} приказује употребу два влакна. У оквиру једног се чека на промену вредности у сензору за температуру, док се у оквиру другог чека на промену вредности у сензору за влажност ваздуха. Функција \textit{publishOnChange} блокира извршавање док се у сензору за који је позвана не деси промена вредности. На овај начин је омогућено да се у оквиру једног процеса чека на више ствари, и нема паралелизма, већ се уколико дође до блокирања у једном влакну, прелази на извршавање следећег који је спреман за извршавање.

\item Корутине

Дартино има уграђену подршку за корутине. Корутине су објекти налик на функције, које могу давати више вредности, па су веома сличне генераторима. Када корутина врати вредност, зауставља се на тренутној позицији, а њен стек извршавања се чува за касније покретање. Када врати последњу вредност, сматра се завршеном, и више се не може покретати.

\begin{listing}
\begin{minted}[bgcolor=olive!10]{javascript}
var co = new Coroutine((x) {
    Expect.isTrue(co.isRunning);
    Expect.equals(1, x);
    Expect.equals(2, Coroutine.yield(4));
    Expect.isTrue(co.isRunning);
});

Expect.isTrue(co.isSuspended);
Expect.equals(4, co(1));
Expect.isTrue(co.isSuspended);
Expect.isNull(co(2));
Expect.isTrue(co.isDone);
\end{minted}
\caption{Употреба корутина}
\label{coroutines}
\end{listing}

\item Динамичко отпремање метода (енг.~\textit{Dynamic dispatch})

Динамичко отпремање метода се односи на позивање полиморфних метода класа, при чему се који метод треба позвати разрешава у фази извршавања, а не у фази превођења. Прави се табела отпремања, која се имплементира као низ, у који се сваки метод, сваке класе, смешта на своју позицију. Позиција метода у табели се рачуна помоћу редног броја класе и позиције метода. У току извршавања, на основу ове табеле се одлучују који метод треба позвати. Оно што је неопходно при добијању одређеног метода из табеле, је провера да ли је резултат заправо оно што нам треба. Уколико није, значи да тражени метод одређене класе не постоји. Загарантовано је константно време отпремања, и табела отпремања се израчунава пре извршавања, па представља део апликације.

\begin{listing}
\begin{minted}[bgcolor=olive!10]{javascript}
class A {
  metod1();
}
class B extends A {
  metod2();
}
class C extends B {
  metod1();
}
class D extends A {
  metod3();
}
\end{minted}
\caption{Пример хијерархије класа помоћу ког се илуструје генерисање табеле отпремања метода}
\label{dispatchTable}
\end{listing}

У коду \ref{dispatchTable} је представљено неколико класа којима се преклапају методи. Процес генерисања табеле отпремања је следећи: Класама редом придружимо бројеве: 0, 1, 2 и 3. Методима придружимо позиције на мало компликованији начин: методу \textit{metod1}, који је дефинисан у највећем броју класа, придружимо позицију 0, и он се смешта на почетак табеле. Методу \textit{metod2} придружимо позицију 3, и методу \textit{metod3} придружимо 4. Позиције морају бити јединствени бројеви, како не би дошло до преклапања метода. Пример табеле отпремања за ове класе приказан је на слици \ref{fig:otpremanje}. Приметимо да се могу појавити празне позиције у табели.

\begin{figure}[!ht]
  \centering
  \includegraphics[width=0.7\textwidth]{otpremanje.jpg}
  \caption{Табела отпремања за класе у примеру \ref{dispatchTable}}
  \label{fig:otpremanje}
\end{figure}


\end{enumerate}

\section{Најзначајније библиотеке}
Ради прилагођавања програмског језика Дарт специфичностима микроконтролера, развијена је нова библиотека \textit{,,dartino''}. Она се састоји из више мањих библиотека, а неке од најзначајних су описане у наставку.

\begin{enumerate}

\item ~\textbf{file} - Интерфејс за рад са датотекама. Подржано само када се Дартино извршава на ПОСИКС платформи.

\item ~\textbf{ffi} - ,,foreign function interface'' библиотека која омогућава да се из Дарт кода позивају функције дефинисане у неком другом програмском језику, нпр. функције програмског језика Ц.

\item ~\textbf{http} - Имплементација ХТТП (енг.~\textit{HTTP - HyperText Transfer Protocol}) клијента.

\item ~\textbf{mbedtls} - ТЛС (енг.~\textit{TLS - Transport Layer Security}) подршка, базирана на mbedtls. Ово се може користити на исти начин као нормални сокет (и да се прослеђује ХТТП пакету).

\item ~\textbf{mqtt} - MQTT клијентска библиотека за MQTT протокол, ИоТ протокол за размену порука заснован на објављивању/претплати.

\item ~\textbf{os} - Приступ оператитивном систему. Подржано када се Дартино извршава на ПОСИКС платформи.

\item ~\textbf{socket} - Дартино имплементација ТЦП (енг.~\textit{TCP - Transmission Control Protocol}) и УДП (енг.~\textit{UDP - User Datagram Protocol}) сокета

\item ~\textbf{stm32} - Подршка за STM32 плоче.

\end{enumerate}

\section{Покретање Дарт програма унутар виртуелне машине}
\label{sec:pokretanje}

Примарни начин за комуникацију са Дартино виртуелном машином је преко команде ~\textbf{dartino}. Ова команда комуницира са процесом који се извршава а не захтева интеракцију са корисником (енг.~\textit{persistent process}), који ради сав тежи посао. Помоћу њега ~\textbf{dartino} компајлира програм, a помоћу Дартино виртуелне машине (~\textbf{dartino-vm}) извршава и дебагује програме .\\

Нешто више о извршним фајловима које се користе при покретању програма:
\begin{enumerate}
\item ~\textbf{dartino}\\
Ова команда је C++ програм. Намера је била да буде што једноставнији програм који једноставно прослеђује стандардне улазно/излазне сигнале процесу који се извршава а не захтева интеракцију, преко сокета. Ово је мали извршни фајл за покретање компилатора. Компилатор је написан у Дарту и извршава се у оквиру Дарт виртуелне машине. То је ЈИТ компилатор.
\item ~\textbf{dartino-vm} \\
Самостална виртуелна машина која подржава превођење програма и покретање програма из бајткода.
\item ~\textbf{dart} \\
Процес који се извршава а не захтева интеракцију са корисником. То је Дарт програм: Класична Дарт виртуелна машина за покретање компилатора. Овај извршни фајл се не генерише у оквиру Дартина, већ је део Дарта. Процес се састоји из главне нити, и неколико воркера. Главна нит ослушкује надолазеће конекције из ~\textbf{dartino} команде, и може да користи воркере да обави тражени задатак.
\end{enumerate}

Шта се заправо дешава када се покрене команда ~\textbf{dartino run hello.dart}? Дартино је подразумевано повезан на локалну сесију, која је повезана на локалну виртуелну машину која ради на нашем рачунару. ~\textbf{dartino} преводи код до бајткода, помоћу Дарт компилатора, а онда га прослеђује ~\textbf{dartino-vm} која га извршава. Дартино виртуелна машина враћа резултат назад Дартину, и он га приказује.

Дартино подржава више сесија. Свака сесија може бити придружена различитој Дартино виртуелној машини, што омогућује кориснику да тестира више разлићитих уређаја истовремено. Тренутно је руковање сесијама експлицитно.

\begin{figure}[!ht]
  \centering
  \includegraphics[width=0.9\textwidth]{sesije.png}
  \caption{Процес извршавања програма}
  \label{fig:izvrsavanje}
\end{figure}

Покретање програма у оквиру одређене сесије је омогућено на следећи начин: 

~\textbf{./out/DebugXMIPS/dartino create session my\_session}\\
Креирање нове сесије ,,my\_session''.

Након тога морамо да покренемо дартино виртуелну машину:

~\textbf{./out/DebugXMIPS/dartino-vm}\\
Након чега се исписује порука типа ,,Waiting for compiler on 127.0.0.1:61745''. 61745 представља рандом генерисани порт.

У новом терминалу се прикачимо на дати сокет:

~\textbf{./out/DebugXMIPS/dartino attach tcp\_socket 127.0.0.1:61745 in session my\_session}\\

А затим покренемо жељени програм у оквиру те сесије:

~\textbf{./out/DebugXMIPS/dartino run hello.dart in session my\_session}\\

Сесија се прекида помоћу следеће команде:

~\textbf{./out/DebugXMIPS/dartino x-end session my\_session}\\


% ------------------------------------------------------------------------------
\chapter{Имплементација интерпретатора за платформу МИПС}
\label{chp:implementacija}
% ------------------------------------------------------------------------------
У овом поглављу биће описан поступак имплементације интерпретатора за платформу МИПС, кроз делове кода и тест примере за које су одређене целине имплементиране. Након тога биће описан стек Дартино виртуелне машине, а затим и имплементирани систем за дебаговање. На крају ће бити описани још неки значајни тест примери, резултати тестирања на постојећем скупу тестова и апликација у језику Дарт имплементирана за потребе упоређивања перформанси интерпретатора.

\section{Имплементација у програмском језику Ц++}
Имплементација је рађена на рачунару са Интел x86 процесором, крос-компилацијом, при чему је циљна архитектура  МИПС32Р2. У почетку развоја, постојао је мултинаменски интерпретатор, који не зависи од архитектуре. Требало је само конфигурисати Дартино за платформу МИПС, и тиме би превођење за МИПС било омогућено. Конфигурисање подразумева додавање опције "mips" у списку подржаних архитектура и додавање опција које се користе приликом превођења. Да би се при превођењу добио одговарајући извршни фајл, било је непходно гцц-у проследити аргументе који указују на МИПС архитектуру: \textit{-mips32r2}, \textit{-EL}, и линкеру проследити \textit{-EL}, што указује на литл ендиан (енг.~\textit{little endian}\footnote{Начин записа података у меморији тако да је на нижој адреси нижи бит меморијске речи.}). Да би се у фази линковања користиле МИПС библиотеке, постављене су путање до њиx. 
МИПС извршне датотеке се покрећу помоћу КЕМУ (енг.~\textit{QEMU - Quick Emulator}) емулатора у корисничком режиму\footnote{У овом режиму КЕМУ може покретати процесе преведене за једну врсту процесора на другој врсти процесора}. Да би се то вршило аутоматски, непходно је команди \textbf{update-binfmts} проследити вредности које одговарају мипс ЕЛФ (енг.~\textit{ ELF - format of Executable and Linking Format} \footnote{Бинарни формат извршних датотека на Линукс оперативном систему}) датотекама, и путању до скрипте која покреће КЕМУ емулатор. На овај начин ће се при покретању извршних датотека чије се меџик (енг.~\textit{magic}) и маск (енг.~\textit{mask}) вредности поклапају са овим, покретање извршити помоћу КЕМУ емулатора за МИПС. Команда са одговарајућим аргументима је представљена кодом \ref{qemu_komanda}, док је скрипта која покреће КЕМУ представљена кодом \ref{skripta}. \\

\begin{listing}
\centering
\begin{minted}[bgcolor=olive!10]{awk}
sudo update-binfmts --install qemu-mipsel /<skripta>
--magic '\x7fELF\x01\x01\x01\x00\x00\x00\x00
        \x00\x00\x00\x00\x00\x02\x00\x08\x00'
--mask '\xff\xff\xff\xff\xff\xff\xff\x00\xfe\xff
        \xff\xff\xff\xff\xff\xff\xfe\xff\xff\xff'
--credentials yes --package qemu-user-static
\end{minted}
\caption{Команда за аутоматско покретање МИПС извршних датотека помоћу КЕМУ-a. <skripta> представља путању до скрипте \ref{skripta}:}
\label{qemu_komanda}
\end{listing}


\begin{listing}
\centering
\begin{minted}[bgcolor=olive!10]{awk}
#!/bin/bash
qemu=/<qemu>/mipsel-linux-user/qemu-mipsel
exec $qemu $*
\end{minted}
\caption{Скрипта у којој се покреће КЕМУ емулатор}
\label{skripta}
\end{listing}
Где <qemu> представља путању до директоријума у ком се налази qemu емулатор.

Интерпретатор за платформу МИПС је урађен по угледу на постојећи интерпретатор за АРМ процесоре.\\
За почетак су направљене датотеке \textit{assembler\_mips.h} и \textit{assembler\_mips.cc} које описују МИПС асемблерски језик. Најпре је најпре дефинисана енумерација регистар која обухвата  МИПС регистре (референца на део о мипс регистрима). Направљене су класе \textit{Label}, \textit{Constant} и \textit{Address}. 

\begin{listing}
\begin{minted}[bgcolor=olive!10]{cpp}
class Label {
 public:
  Label() : position_(-1) {}

  int position() {
    if (position_ == -1) position_ = position_counter_++;
    return position_;
  }

 private:
  int position_;
  static int position_counter_;
}; 
\end{minted}
\caption{Класа помоћу које се генеришу лабеле у МИПС асемблерском језику}
\label{label}
\end{listing}

Лабела представља линију у оквиру асемблерског фајла на коју се може скочити. У коду \ref{label} је представљена класа \textit{Label} која садржи два поља: \textit{position} - представља редни број лабеле и \textit{position\_counter} - заједничка променљива за све инстанце класе \textit{Label}, на основу које се додељује позиција лабеле.\\

\begin{listing}
\begin{minted}[bgcolor=olive!10]{cpp}
class Immediate {
 public:
  explicit Immediate(int32_t value) : value_(value) {}
  int32_t value() const { return value_; }

 private:
  const int32_t value_;
};
\end{minted}
\caption{Класа помоћу које се генеришу константе у МИПС асемблерском језику}
\label{konstanta}
\end{listing}

У коду \ref{konstanta} је представљена класа \textit{Immediate}. Инстанца те класе представља константу вредност целобројног типа.\\

\begin{listing}
\begin{minted}[bgcolor=olive!10]{cpp}
class Address {
 public:
  Address(Register base, int32_t offset)
      : base_(base), offset_(offset) {}

  Register base() const { return base_; }
  int32_t offset() const { return offset_; }

 private:
  const Register base_;
  const int32_t offset_;
};
\end{minted}
\caption{Класа помоћу које се представљају меморијске у МИПС асемблерском језику}
\label{adresa}
\end{listing}

У коду \ref{adresa} је представљена класа \textit{Address}. Инстанца те класе представља меморијску адресу, која је на платформи МИПС32Р2 32-битна. Адреса се рачуна као збир адресе у базном регистру и помераја. Базни регистар је регистар опште намене који садржи 32-битну адресу. 

Дефинисани су макрои за МИПС инструкције са одговарајућим бројем аргумената, помоћу којих ће се по потреби увести одговарајуће инструкције које се користе при интерпретацији.\\

\begin{listing}
\begin{minted}[bgcolor=olive!10]{cpp}
#define INSTRUCTION_3(name, format, t0, t1, t2)  \
  void name(t0 a0, t1 a1, t2 a2) {               \
    Print(format, Wrap(a0), Wrap(a1), Wrap(a2)); \
  }
\end{minted}
\caption{Макро за генерисање инструкције која има 3 аргумента}
\label{instrukcija}
\end{listing}

У коду \ref{instrukcija} представљен је пример макроа за генерисање МИПС асемблерских инструкција које имају 3 аргумента. Аналогно томе, постоје макрои за генерисање инструкција са 1, 2 и 4 аргумента.

Након тога је имплементирана функција \textit{Print} за уписивање асемблерских инструкција у фајл. Дефинисан је начин записивања регистара, лабела и адреса у МИПС асемблеру.\\

\begin{listing}
\begin{minted}[bgcolor=olive!10]{cpp}
case 'l': {
  Label* label = va_arg(arguments, Label*);
  printf(".L%d", label->position());
  break;
}
\end{minted}
\caption{Пример записивања лабеле у МИПС асемблерском језику}
\label{print_labela}
\end{listing}

У коду \ref{print_labela} представљен је део функције \textit{Print} који се односи начин записивања лабеле унутар асемблерског фајла. Пре позиције додаје се префикс ,,.L'' који означава да је у питању лабела.

\begin{listing}
\begin{minted}[bgcolor=olive!10]{cpp}
case 'r': {
  Register reg = static_cast<Register>(va_arg(arguments, int));
  printf("\$%s", ToString(reg));
  break;
 }
\end{minted}
\caption{Пример записивања регистра у МИПС асемблерском језику}
\label{print_registar}
\end{listing}
У коду \ref{print_registar} представљен је део функције \textit{Print} који се односи начин записивања регистра унутар асемблерског фајла. Регистар се означава префиксом ,,\$'', након чега следи ознака регистра.

\begin{listing}
\begin{minted}[bgcolor=olive!10]{cpp}
void Assembler::PrintAddress(const Address* address) {
  printf("\%d(\$%s)", address->offset(), ToString(address->base()));
}
\end{minted}
\caption{Пример записивања адресе у МИПС асемблерском језику}
\label{print_adresa}
\end{listing}
У коду \ref{print_adresa} представљен је део функције \textit{Print} који се односи начин записивања адресе унутар асемблерског фајла. Адреса се записује као померај иза ког следи у загради запис базног регистра.


На овај начин је омогућено генерисање МИПС асемблерског кода. Следећи корак је генерисање интерпретатора. Интерпретатор генерише асемблерску датотеку чијим превођењем добијамо програм који извршава бајткод на МИПС архитектури. Већина функција у интерпретатору представља имплементацију одговарајућих Дартино процедура.

Најпре су имплементиране специфичности у вези са МИПС позивном конвенцијом(референца). Функција \textit{GeneratePrologue} служи за генерисање асемблерског кода који ће се извршити приликом позива сваке  функције. Мора се сачувати садржај регистара S0-S7 на стеку, и такође садржај регистра RA, у ком се налази адреса повратка функције. По повратку из неке функције, позива се функција \textit{GenerateEpilogue} у којој се скида са стека садржај регистара S0-S7 и регистра RA.

При скоку на функцију која се налази ван интерпретатора, мора се позвати функција за поравнање стека. Ова функција је представљена кодом \ref{prepare_stack}.
На основу позивне конвенције, неопходно је резервисати 4 места на стеку за аргументе функције (уколико функција коју позивамо позива неку другу функцију). Осим тога, неопходно је сачувати садржај регистра GP. Стек увек мора бити поравнат на 8 (адреса стека мора бити дељива са 8), па се због тога сачува 6 речи уместо 5.\\

\begin{listing}
\begin{minted}[bgcolor=olive!10]{javascript}
void InterpreterGeneratorMIPS::PrepareStack() {
  __ addiu(SP, SP, Immediate(-6 * kWordSize));
  __ sw(GP, Address(SP, 5 * kWordSize));
}
\end{minted}
\caption{Пример функције за поравнање стека, која се позива пре скока на неку спољну функцију}
\label{prepare_stack}
\end{listing}

По повратку из неке спољне функције, позива се функција \textit{RestoreStack}, која ради инверзну операцију функције \textit{PrepareStack}. Ова функција је представљена кодом \ref{restore_stack}.\\

\begin{listing}
\begin{minted}[bgcolor=olive!10]{javascript}
void InterpreterGeneratorMIPS::RestoreStack() {
  __ lw(GP, Address(SP, 5 * kWordSize));
  __ addiu(SP, SP, Immediate(6 * kWordSize));
}
\end{minted}
\caption{Пример функције за поравнање стека, која се позива по повратку из неке спољне функцију}
\label{restore_stack}
\end{listing}

Након тога настављена је постепена имплементација интерпретатора. Први циљ је био превођење програма који декларише променљиву и иницијализује је на вредност 42, а затим је исписује на стандардни излаз. Овај програм је представљен кодом \ref{return_42}.\\

\begin{listing}
\begin{minted}[bgcolor=olive!10]{javascript}
main() {
  var number = 42;
  print(\${number});
}
\end{minted}
\caption{Прoграм за исписивање броја 42 у програмском језику Дарт}
\label{return_42}
\end{listing}

Направљени су механизми за дебаговање у МИПС и АРМ асемблеру који садрже две опције: могућност исписивања редног броја функције интерпретатора која се тренутно извршава и могућност исписивања садржаја задатог регистра. Ти механизми су у процесу развоја били део интерпретатора. Коришћени су како би се извршавањем програма на АРМ архитектури добила информација о функцијама које је неопходно имплементирати да би се тај програм извршио на МИПС архитектури. Такође, када дође до грешке и прекида извршавања програма, овај механизам нам омогућава да знамо у којој функцији је дошло до грешке. Више о овом механизму може се прочитати у одељку \ref{sec:debagovanje}.

Након програма који исписује број 42, имплементиран је остатак функција који је неопходан за исписивање поруке "Здраво свете". Пример Дарт програма који исписује поруку представљен је кодом \ref{hello_world}.\\

\begin{listing}
\begin{minted}[bgcolor=olive!10]{javascript}
main() {
  print("Hello world");
}
\end{minted}
\caption{Прoграм за исписивање поруке "Hello world" у програмском језику Дарт}
\label{hello_world}
\end{listing}

Затим су имплементиране функције неопходне за превођење програма са основним аритметичким операцијама, рад са низовима, битовски оператори и слично. Кодом \ref{function_add} представљена је функција која сабира два броја, при чему се проверава да ли је дошло до прекорачења. Уколико је било прекорачења, непходно је скочити на део кода који врши опоравак.\\

\begin{listing}
\begin{minted}[bgcolor=olive!10]{cpp}
void InterpreterGeneratorMIPS::InvokeAdd(const char* fallback) {
  Label no_overflow;
  LoadLocal(A0, 1);
  __ andi(T0, A0, Immediate(Smi::kTagMask));
  __ B(NEQ, T0, ZR, fallback);
  LoadLocal(A1, 0);
  __ andi(T1, A1, Immediate(Smi::kTagMask));
  __ B(NEQ, T1, ZR, fallback);

  __ xor_(T1, A0, A1);
  __ b(LT, T1, ZR, &no_overflow);
  __ addu(T0, A0, A1);  // Delay-slot.
  __ xor_(T1, T0, A0);
  __ b(LT, T1, ZR, fallback);
  __ Bind(&no_overflow);
  __ move(A0, T0);  // Delay-slot.
  DropNAndSetTop(1, A0);
  Dispatch(kInvokeAddLength);
}
\end{minted}
\caption{Функција у МИПС интерпретатору која сабира две целобројне вредности}
\label{function_add}
\end{listing}

Након тога имплементиране су функције које су неопходне да би се исправно извршио програм који исписује поздравну поруку и информације о машини на којој се програм извршава, и тај програм представљен је кодом \ref{hello_from}.\\

\begin{listing}
\begin{minted}[bgcolor=olive!10]{cpp}
main() {
  SystemInformation si = sys.info();
  String nodeInformation =
      si.nodeName.isEmpty ? '' : ' running on \${si.nodeName}';
  print('Hello from ${si.operatingSystemName}$nodeInformation.');
}
\end{minted}
\caption{Програм који исписује ,,Hello'' и информације о машини на којој се извршава }
\label{hello_from}
\end{listing}

На крају су имплементиране преостале функције, како би се могао покренути постојећи скуп тестова.

\section{Дартино стек}

У оквиру Дартино виртуелне машине се ради са локалним стеком, и за те потребе је искоришћен регистар S2. Све операције са стеком у оквиру интерпретатора се раде над тим стеком, при чему стек процесора користи Дарт виртуелна машина, односно компајлер.
Функције која врши скидање садржаја са стека је представљена кодом \ref{pop}. У регистар се упише садржај са врха стека, а затим се врх стека помери за дужину једне речи, односно садржај се скине са стека.
Функција која поставља садржај на стек је представљена кодом \ref{push}. На стеку се алоцира меморија за једну реч (помери се врх стека), а затим се садржај регистра упише на врх стека.\\

\begin{listing}
\begin{minted}[bgcolor=olive!10]{cpp}
void InterpreterGeneratorMIPS::Pop(Register reg) {
  __ lw(reg, Address(S2, 0));
  __ addiu(S2, S2, Immediate(1 * kWordSize));
}
\end{minted}
\caption{Функција за скидање садржаја регистра са локалног Дартино стека.}
\label{pop}
\end{listing}

\begin{listing}
\begin{minted}[bgcolor=olive!10]{cpp}
void InterpreterGeneratorMIPS::Push(Register reg) {
  __ addiu(S2, S2, Immediate(-1 * kWordSize));
  __ sw(reg, Address(S2, 0));
}
\end{minted}
\caption{Функција за чување садржаја регистра на локалном Дартино стеку.}
\label{push}
\end{listing}

\section{Систем за дебаговање}
\label{sec:debagovanje}

С обзиром да се функције у интерпретатору извршавају у току превођења кода, а не у току изврашавања, било је неопходно да се систем за дебаговање угради у асемблерски код.

У коду \ref{push_asm} представљен је макро у оквиру ког се налазе инструкције за чување садржаја регистра на стеку. Чување садржаја на стеку је имплементирано као у функцији која је представљена кодом \ref{push}, при чему је једина разлика то што се ради са процесорским стеком.

У коду \ref{pop_asm} представљене су инструкције за скидање садржаја регистра на стеку. Макро је имплеметиран исто као функција у коду \ref{pop}. 

\begin{listing}
\begin{minted}[bgcolor=olive!10]{cpp}
#define push_asm(reg)                               \
  assembler()->subi(SP, SP, Immediate(1*kWordSize));\
  assembler()->sw(reg, Address(SP, 0));
\end{minted}
\caption{Макро за чување садржаја регистра са стека. }
\label{push_asm}
\end{listing}

\begin{listing}
\begin{minted}[bgcolor=olive!10]{cpp}
#define pop_asm(reg)                                \
  assembler()->lw(reg, Address(SP, 0));             \
  assembler()->addi(SP, SP, Immediate(1*kWordSize));
\end{minted}
\caption{Макро за скидање садржаја регистра са стека. }
\label{pop_asm}
\end{listing}

\begin{listing}
\begin{minted}[bgcolor=olive!10]{cpp}
#define PrintRegister(reg)                      \
  push_asm(GP);                                 \
  push_asm(V0);                                 \
  push_asm(A0);                                 \
  push_asm(A1);                                 \
  push_asm(T9);                                 \
  push_asm(RA);                                 \
  assembler()->la(A0, "print_reg");             \
  assembler()->move(A1, reg);                   \
  assembler()->lw(T9, "\%call16(printf)(\$gp)");\
  assembler()->jalr(T9);                        \
  assembler()->nop();                           \
  pop_asm(RA);                                  \
  pop_asm(T9);                                  \
  pop_asm(A1);                                  \
  pop_asm(A0);                                  \
  pop_asm(V0);                                  \
  pop_asm(GP);                                  
\end{minted}
\caption{Макро за исписивање садржаја регистра }
\label{print_reg}
\end{listing}

У коду \ref{print_reg} приказан је макро који се користи да би се исписао садржај регистра. Неопходно је сачувати садржај регистара који се користе у макроу, како систем за дебаговање не би утицао на извршавање остатка програма. У А0 се смешта адреса ниске "print\_reg", коју генерише функција \textit{GenerateDebugStrings} док се у А1 сачува садржај регистра који је аргумент макроа. Након тога се скочи на функцију \textit{printf}, при чему се у А0 и А1 налазе аргументи функције. Сличан макро генерисан је за записивање редног броја функције интерпретатора која се тренутно извршава.\\

\begin{listing}
\begin{minted}[bgcolor=olive!10]{cpp}
void InterpreterGeneratorMIPS::GenerateDebugStrings() {
  int i;
  char *str = (char *)malloc(10);
  printf("\n\t.data\n");
  for(i=1;i<=255;i++) {
    sprintf(str, "string_\%d", i);
    printf("\%s: .asciiz \"\%d   \"\n", str, i);
  }
  printf("print_reg: .asciiz \"register_value: \%\%x\\n\"\n");
  free(str);
}
\end{minted}
\caption{Функција која генерише ниске које се користе при дебаговању, у сектору података у асемблерској датотеци }
\label{generate_debug_strings}
\end{listing}

У коду \ref{generate_debug_strings} приказана је функција која се користи при генерисању ниски које се користе при дебаговању: ,,string\_редни\_број\_ниске'' и ,,print\_reg''. Ниска  ,,string\_редни\_број\_ниске'' представља лабелу која се записује у сектору података, иза које следи ,,.asciiz'', што представља тип податка, и на крају сам податак, односно број. Ова ниска се користи при исписивању редног броја функције у интерпретатору која се тренутно извршава.
Ниска ,,print\_reg'' користи се се исписивању садржаја регистра, што се може видети у коду \ref{print_reg}. Ова ниска такође представља лабелу у сектору података, иза које следи тип ,,.asciiz'', и на крају вредност податка, односно садржај регистра који се исписује. Више о запису у сектору података у МИПС асемблерском језику може се прочитати у поглављу РЕФЕРЕНЦА\_НА\_ПОГЛАВЉЕ\_У\_МИПСУ.

\section{Тестирање и резултати}
Упоредо са имплементацијом интерпретатора, писани су мали тест примери. Примери неких тестова дати су у опису имплементације. Овде ће бити наведени још неки од тестова који су помогли у решавању највећих багова.

Један од проблема који се јавио у току имплементације је функција \textit{signalfd}, која у QEMU емулатору за МИПС није била имплементирана. То је установљено тест примером који је приказан кодом \ref{signal_fd}.\\

\begin{listing}
\begin{minted}[bgcolor=olive!10]{cpp}
int fd = signalfd(-1, &signal_mask, SFD_CLOEXEC);
  if (fd == -1) {
    FATAL1("signalfd failed: %s", strerror(errno));
  }
\end{minted}
\caption{Позив функције \texttt{signalfd}, који је производио грешку при извршавању }
\label{signal_fd}
\end{listing}

Након тога је направљен тест у програмском језику Ц, у ком се такође користи функција \textit{signalfd}, и преведен за МИПС, како би се утврдило да ли разлог због ког не пролази тест има везе са интерпретатором. При извршавању тог теста јављала се грешка неподржане функције. Kaда je подршка за функцију додата у оквиру КЕМУ емулатора, тест је прошао.

Приликом тестирања рада са сокетима јавила се грешка при позиву функције \textit{Socket.connect}, односно функције \textit{sys.socket} која се налази у оквиру ње. Пример позива те функције дат је кодом \ref{sys.socket}.\\

\begin{listing}
\begin{minted}[bgcolor=olive!10]{cpp}
fd = sys.socket(sys.AF_INET, sys.SOCK_STREAM, 0);
\end{minted}
\caption{Позив функције \texttt{sys.socket}, који је производио грешку при извршавању }
\label{sys.socket}
\end{listing}

Утврђено је да унутар Дартина вредност макроа SOCK\_STREAM није прилагођена МИПС архитектури, која користи различите вредности неких системских макроа у односу на остале архитектуре.

Направљено је и неколико тест примера у којима је уочен проблем при позиву функције \textit{sys.setsockopt}, којој су прослеђиване погрешне вредности макроа SOL\_SOCKET и SO\_REUSEADDR. Пример позива те функције представљен је кодом \ref{sys.setsockopt}.\\

\begin{listing}
\begin{minted}[bgcolor=olive!10]{cpp}
int _setReuseaddr(int fd) {
    int result =
      sys.setsockopt(fd, sys.SOL_SOCKET, sys.SO_REUSEADDR, FOREIGN_ONE);
    return result;
  }
\end{minted}
\caption{Позив функције \texttt{sys.setsockopt}, који је производио грешку при извршавању }
\label{sys.setsockopt}
\end{listing}

Сличан проблем уочен је при прављењу теста у ком се генерише нова датотека. Проблем је био у макроима који се користе при системском позиву open: O\_CREAT, O\_APPEND и O\_NONBLOCK.

Кодом \ref{system_linux_dart} представљен је део Дартино датотеке \textit{,,system\_linux.dart''}, док је кодом \ref{system_posix_dart} представљен део датотеке \textit{,,system\_posix.dart''} (које се налазе у оквиру библиотеке за приступ оперативном систему) у којима су исправљене вредности одговарајућих макроа, тако да зависе од архитектуре. Исправне вредности макроа за МИПС платформу добијене су читањем одговарајућих датотека у оквиру МИПС тулчејна (енг.~\textit{toolchain}). \\

\begin{listing}
\begin{minted}[bgcolor=olive!10]{cpp}
  static final bool isMips = sys.info().machine == 'mips';
  int get AF_INET6 => 10;

  int get O_CREAT => isMips ? 256 : 64;
  int get O_TRUNC => 512;
  int get O_APPEND => isMips ? 8 : 1024;
  int get O_NONBLOCK => isMips ? 128 : 2048;
  int get O_CLOEXEC => 524288;

  int get FIONREAD => isMips ? 0x467f : 0x541b;
  int get SOL_SOCKET => isMips ? 65535 : 1;
  int get SO_REUSEADDR => isMips ? 4 : 2;
\end{minted}
\caption{Део датотеке \texttt{,,system\_linux\_dart''} у ком су одговарајући макрои, тако да им вредности зависе од архитектуре}
\label{system_linux_dart}
\end{listing}

\begin{listing}
\begin{minted}[bgcolor=olive!10]{cpp}
  int get SOCK_STREAM => isMips ? 2 : 1;
  int get SOCK_DGRAM => isMips ? 1 : 2;
\end{minted}
\caption{Део датотеке \texttt{,,system\_posix\_dart''} у ком су одговарајући макрои, тако да им вредности зависе од архитектуре}
\label{system_posix_dart}
\end{listing}

На крају имплементације, покренут је скуп тестова који је део Дартино пројекта. Тестови се покрећу помоћу пајтон (енг.~\textit{python}) скрипте \textit{tools/test.py}, а пример покретања тестова на платформи МИПС представљен је кодом \ref{test_py}. Неопходно је навести на којој се платформи покрећу тестови. Пошто је за неке тестове потребно мало више времена од подразумеваног, потребно је навести временско ограничење (енг.~\textit{timeout}) од 1200 секунди. Разлог зашто се неки тестови извршавају дуже него на АРМ платформи је што на МИПС32Р2 не постоје неке инструкције које постоје на АРМ архитектури, па је било неопходно имплементирати их помоћу већег броја инструкција. Убрзање би се постигло уколико би нам референтна платформа била МИПС64Р6, јер је уведен нови, богатији, скуп инструкција.\\

\begin{listing}
\begin{minted}[bgcolor=olive!10]{awk}
tools/test.py -axmips -t1200
\end{minted}
\caption{Команда за покретање тестова на платформи МИПС}
\label{test_py}
\end{listing}

Постојећим скуповима тестова тестиране су следеће карактеристике језика:
\begin{enumerate}
\item Корутине
\item Влакна
\item Изолате
\item Kоришћење функција неких других програмских језика
\item Конекција на ХТТПС сервер коришћењем ТЛС протокола
\item Рад са уграђеним библиотекама
\end{enumerate}

Резултат тестирања на платформи МИПС може се видети на слици \ref{fig:mips}. Тестови се у просеку извршавају за 45 минута, при навођењу временског ограничења од 1200 секунди.
На плаформи АРМ се тестови извршавају за око 50 минута, при временском ограничењу од 600 секунди. То се може видети на слици \ref{fig:arm}.
Тестови се на платформи Интел x86 извршавају за 20 минута, без потребног временског ограничења. То је представљено на слици \ref{fig:x86}.

\begin{figure}[!ht]
  \centering
  \includegraphics[width=0.7\textwidth]{testovi-mips.png}
  \caption{Резултати тестирања на платформи МИПС}
  \label{fig:mips}
\end{figure}

\begin{figure}[!ht]
  \centering
  \includegraphics[width=0.7\textwidth]{testovi-arm.png}
  \caption{Резултати тестирања на платформи АРМ }
  \label{fig:arm}
\end{figure}

\begin{figure}[!ht]
  \centering
  \includegraphics[width=0.7\textwidth]{testovi_x64.png}
  \caption{Резултати тестирања на платформи x86-64}
  \label{fig:x86}
\end{figure}

\section{Пример апликације у програмском језику Дарт}


% ------------------------------------------------------------------------------
\chapter{Закључак}
% ------------------------------------------------------------------------------


% ------------------------------------------------------------------------------
% Literatura
% ------------------------------------------------------------------------------
\literatura

% ==============================================================================
% Završni deo teze i prilozi
\backmatter
% ==============================================================================

% ------------------------------------------------------------------------------
% Biografija kandidata

% ------------------------------------------------------------------------------

\end{document} 
